#-----------------------------------------------------------
# Vivado v2018.2 (64-bit)
# SW Build 2258646 on Thu Jun 14 20:02:38 MDT 2018
# IP Build 2256618 on Thu Jun 14 22:10:49 MDT 2018
# Start of session at: Tue Jun 11 19:46:05 2019
# Process ID: 13059
# Current directory: /home/saverio/Scrivania/tesi/script/bram
# Command line: vivado -mode tcl
# Log file: /home/saverio/Scrivania/tesi/script/bram/vivado.log
# Journal file: /home/saverio/Scrivania/tesi/script/bram/vivado.jou
#-----------------------------------------------------------
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl 
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {$i<$offset-32 } {
# 
# 			}
# 				while {$i<$offset} {
# 					if {$stessa_word ==1} {
# 						set stessa_word 0
# 						#append bram "word"
# 						append bram [format %08X $word]
# 						#puts "word [format %X $word] "
# 					}
# 					#al massimo saltiamo 15 frame
# 					if {$frame_da_saltare<15} {
# 						set i [expr {$i + 32}]
# 						set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 						puts "qui $frame_da_saltare"
# 
# 
# 					} else {
# 						#append bram " salto"
# 						set i [expr {$i + 32}]
# 						append bram 00000000 
# 						#append bram [format %X $frame_da_saltare] 
# 						#append bram " "
# 						
# 						#append bram " "
# 						
# 						#set frame_da_saltare -1
# 						
# 					}
# 				}
# 
# 				#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 				#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 				if {$stessa_word ==0} {
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					puts "frame_da_saltare $frame_da_saltare"
# 					set frame_da_saltare -1
# 					#append bram "word"
# 					set word [expr 1 << [expr $offset % 32]]
# 					#puts "word $word"
# 					#append bram [format %X [expr $offset % 32]]
# 					#puts [format %x [expr $offset % 32]]
# 					#append bram " "
# 					set f [expr {$f +1 }]
# 					set stessa_word 1
# 				} else {
# 					
# 					set sec_word [expr 1 << [expr $offset % 32]]
# 					#puts $sec_word
# 					#puts "seconda word $sec_word" 
# 					set f [expr {$f + 1}]
# 					set word [expr $word | $sec_word] 
# 					#questa or mi permette di mettere più offset nella stessa maschera
# 					#puts $word
# 					#append bram [format %X [expr $offset % 32]]
# 					#append bram " "
# 				}
# 			puts "numero word $f"
# 			puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32)} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			}
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32)} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			}
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
unbalanced close paren
in expression "[expr $offset-$i]>32)"
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			}
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
qui 0
qui 1
qui 2
qui 3
qui 4
qui 5
qui 6
qui 7
qui 8
qui 9
qui 10
qui 11
qui 12
qui 13
qui 14
qui 15
offset 540
contatore 512
offset 545
contatore 512
offset 570
contatore 544
offset 579
contatore 544
qui 0
offset 604
contatore 576
offset 609
contatore 576
qui 1
offset 634
contatore 608
offset 643
contatore 608
qui 2
offset 668
contatore 640
offset 673
contatore 640
qui 3
offset 698
contatore 672
offset 707
contatore 672
qui 4
offset 732
contatore 704
offset 737
contatore 704
qui 5
offset 762
contatore 736
offset 771
contatore 736
qui 6
offset 796
contatore 768
offset 801
contatore 768
qui 7
offset 826
contatore 800
offset 835
contatore 800
qui 8
offset 860
contatore 832
offset 865
contatore 832
qui 9
offset 890
contatore 864
offset 899
contatore 864
qui 10
offset 924
contatore 896
offset 929
contatore 896
qui 11
offset 954
contatore 928
offset 963
contatore 928
qui 12
offset 988
contatore 960
offset 993
contatore 960
qui 13
offset 1018
contatore 992
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 000000003
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 3
word modificata con parità 000000003
30000019F00000000F00000000F00000000F00000000F00000000F00000000F000000003
lunghezza 72
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			}
# 			puts "bram $bram"
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
qui 0
qui 1
qui 2
qui 3
qui 4
qui 5
qui 6
qui 7
qui 8
qui 9
qui 10
qui 11
qui 12
qui 13
qui 14
qui 15
bram 00002039f
offset 540
contatore 512
bram 00002039f
offset 545
contatore 512
bram 00002039f00000000F
offset 570
contatore 544
bram 00002039f00000000F
offset 579
contatore 544
qui 0
bram 00002039f00000000F
offset 604
contatore 576
bram 00002039f00000000F
offset 609
contatore 576
qui 1
bram 00002039f00000000F
offset 634
contatore 608
bram 00002039f00000000F
offset 643
contatore 608
qui 2
bram 00002039f00000000F
offset 668
contatore 640
bram 00002039f00000000F
offset 673
contatore 640
qui 3
bram 00002039f00000000F
offset 698
contatore 672
bram 00002039f00000000F
offset 707
contatore 672
qui 4
bram 00002039f00000000F
offset 732
contatore 704
bram 00002039f00000000F
offset 737
contatore 704
qui 5
bram 00002039f00000000F
offset 762
contatore 736
bram 00002039f00000000F
offset 771
contatore 736
qui 6
bram 00002039f00000000F
offset 796
contatore 768
bram 00002039f00000000F
offset 801
contatore 768
qui 7
bram 00002039f00000000F
offset 826
contatore 800
bram 00002039f00000000F
offset 835
contatore 800
qui 8
bram 00002039f00000000F
offset 860
contatore 832
bram 00002039f00000000F
offset 865
contatore 832
qui 9
bram 00002039f00000000F
offset 890
contatore 864
bram 00002039f00000000F
offset 899
contatore 864
qui 10
bram 00002039f00000000F
offset 924
contatore 896
bram 00002039f00000000F
offset 929
contatore 896
qui 11
bram 00002039f00000000F
offset 954
contatore 928
bram 00002039f00000000F
offset 963
contatore 928
qui 12
bram 00002039f00000000F
offset 988
contatore 960
bram 00002039f00000000F
offset 993
contatore 960
qui 13
bram 00002039f00000000F
offset 1018
contatore 992
bram 00002039f00000000F
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 000000003
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 3
word modificata con parità 000000003
30000019F00000000F00000000F00000000F00000000F00000000F00000000F000000003
lunghezza 72
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			}
# 			set frame_da_saltare -1
# 			puts "bram $bram"
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
qui 0
qui 1
qui 2
qui 3
qui 4
qui 5
qui 6
qui 7
qui 8
qui 9
qui 10
qui 11
qui 12
qui 13
qui 14
qui 15
bram 00002039f
offset 540
contatore 512
bram 00002039f
offset 545
contatore 512
qui 0
bram 00002039f
offset 570
contatore 544
bram 00002039f
offset 579
contatore 544
qui 0
bram 00002039f
offset 604
contatore 576
bram 00002039f
offset 609
contatore 576
qui 0
bram 00002039f
offset 634
contatore 608
bram 00002039f
offset 643
contatore 608
qui 0
bram 00002039f
offset 668
contatore 640
bram 00002039f
offset 673
contatore 640
qui 0
bram 00002039f
offset 698
contatore 672
bram 00002039f
offset 707
contatore 672
qui 0
bram 00002039f
offset 732
contatore 704
bram 00002039f
offset 737
contatore 704
qui 0
bram 00002039f
offset 762
contatore 736
bram 00002039f
offset 771
contatore 736
qui 0
bram 00002039f
offset 796
contatore 768
bram 00002039f
offset 801
contatore 768
qui 0
bram 00002039f
offset 826
contatore 800
bram 00002039f
offset 835
contatore 800
qui 0
bram 00002039f
offset 860
contatore 832
bram 00002039f
offset 865
contatore 832
qui 0
bram 00002039f
offset 890
contatore 864
bram 00002039f
offset 899
contatore 864
qui 0
bram 00002039f
offset 924
contatore 896
bram 00002039f
offset 929
contatore 896
qui 0
bram 00002039f
offset 954
contatore 928
bram 00002039f
offset 963
contatore 928
qui 0
bram 00002039f
offset 988
contatore 960
bram 00002039f
offset 993
contatore 960
qui 0
bram 00002039f
offset 1018
contatore 992
bram 00002039f
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 000000005
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 5
word modificata con parità 000000005
30000019F00000000F00000000F00000000F00000000F000000005
lunghezza 54
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			}
# 			if {$frame_da_saltare!=15}
# 			{
# 				append bram 00000000 
# 			 	append bram [format %X $frame_da_saltare] 
# 			 	set frame_da_saltare -1
# 			}
# 			
# 			puts "bram $bram"
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
qui 0
qui 1
qui 2
qui 3
qui 4
qui 5
qui 6
qui 7
qui 8
qui 9
qui 10
qui 11
qui 12
qui 13
qui 14
qui 15
wrong # args: no script following "$frame_da_saltare!=15" argument
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			}
# 			if {$frame_da_saltare!=15} {
# 				append bram 00000000 
# 			 	append bram [format %X $frame_da_saltare] 
# 			 	set frame_da_saltare -1
# 			}
# 			
# 			puts "bram $bram"
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
qui 0
qui 1
qui 2
qui 3
qui 4
qui 5
qui 6
qui 7
qui 8
qui 9
qui 10
qui 11
qui 12
qui 13
qui 14
qui 15
bram 00002039f
offset 540
contatore 512
bram 00002039f
offset 545
contatore 512
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF
offset 570
contatore 544
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF
offset 579
contatore 544
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF000000000
offset 604
contatore 576
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 609
contatore 576
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 634
contatore 608
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 643
contatore 608
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 668
contatore 640
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 673
contatore 640
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 698
contatore 672
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 707
contatore 672
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 732
contatore 704
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 737
contatore 704
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 762
contatore 736
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 771
contatore 736
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 796
contatore 768
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 801
contatore 768
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 826
contatore 800
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 835
contatore 800
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 860
contatore 832
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 865
contatore 832
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 890
contatore 864
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 899
contatore 864
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 924
contatore 896
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 929
contatore 896
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 954
contatore 928
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 963
contatore 928
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 988
contatore 960
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 993
contatore 960
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF000000000
offset 1018
contatore 992
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
36
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
45
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
54
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
63
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
72
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
81
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
90
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
99
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
108
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
117
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
126
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
135
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
144
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
153
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
162
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
171
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
180
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
189
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
198
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
207
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
216
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
225
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
234
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
243
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
252
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
261
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
270
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
279
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
288
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
297
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
306
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
315
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
324
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
333
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
342
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
351
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
360
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
369
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
378
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
387
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
396
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
405
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
414
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
423
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
432
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
441
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
450
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
459
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
468
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
477
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
486
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
495
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
504
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
513
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
522
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
531
byte 00000F000
par 0
word 0
par 0
word 0
par 0
word 7800
par 0
word 7800
word modificata con parità 000007800
540
byte 00000F000
par 0
word 0
par 0
word 0
par 0
word 7800
par 0
word 7800
word modificata con parità 000007800
549
byte 00000F000
par 0
word 0
par 0
word 0
par 0
word 7800
par 0
word 7800
word modificata con parità 000007800
558
byte 00000F000
par 0
word 0
par 0
word 0
par 0
word 7800
par 0
word 7800
word modificata con parità 000007800
567
byte 000005
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 5
word modificata con parità 000000005
30000019F00000000F00000000FFFFFFFFFFEFFFFF800100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000000000100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000000000100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000000000100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000000000100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000007800000007800000007800000007800000000005
lunghezza 576
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			 		puts "bram $bram"
# 			}
# 			if {$frame_da_saltare!=15} {
# 				append bram 00000000 
# 			 	append bram [format %X $frame_da_saltare] 
# 			 	set frame_da_saltare -1
# 			}
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			while {[expr $offset-$i]>32} {
# 					if {$frame_da_saltare<15} {
# 			 			set i [expr {$i + 32}]
# 			 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			 			puts "qui $frame_da_saltare"
# 
# 
# 			 		} else {
# 			 			#append bram " salto"
# 			 			set i [expr {$i + 32}]
# 			 			append bram 00000000 
# 			 			append bram [format %X $frame_da_saltare] 
# 			 			#append bram " "
# 					
# 			 			#append bram " "
# 					
# 			 			set frame_da_saltare -1
# 						
# 			 		}
# 			 		puts "bram $bram"
# 			}
# 			if {$frame_da_saltare!=15} {
# 				append bram 00000000 
# 			 	append bram [format %X $frame_da_saltare] 
# 			 	set frame_da_saltare -1
# 			}
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
qui 0
bram 00002039f
qui 1
bram 00002039f
qui 2
bram 00002039f
qui 3
bram 00002039f
qui 4
bram 00002039f
qui 5
bram 00002039f
qui 6
bram 00002039f
qui 7
bram 00002039f
qui 8
bram 00002039f
qui 9
bram 00002039f
qui 10
bram 00002039f
qui 11
bram 00002039f
qui 12
bram 00002039f
qui 13
bram 00002039f
qui 14
bram 00002039f
qui 15
bram 00002039f
offset 540
contatore 512
offset 545
contatore 512
bram 00002039f00000000F
offset 570
contatore 544
offset 579
contatore 544
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF
offset 604
contatore 576
offset 609
contatore 576
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 634
contatore 608
offset 643
contatore 608
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 668
contatore 640
offset 673
contatore 640
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 698
contatore 672
offset 707
contatore 672
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 732
contatore 704
offset 737
contatore 704
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 762
contatore 736
offset 771
contatore 736
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 796
contatore 768
offset 801
contatore 768
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 826
contatore 800
offset 835
contatore 800
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 860
contatore 832
offset 865
contatore 832
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 890
contatore 864
offset 899
contatore 864
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 924
contatore 896
offset 929
contatore 896
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 954
contatore 928
offset 963
contatore 928
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 988
contatore 960
offset 993
contatore 960
qui 0
bram 00002039f00000000F00000000FFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFFFFFFF
offset 1018
contatore 992
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
36
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
45
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
54
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
63
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
72
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
81
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
90
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
99
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
108
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
117
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
126
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
135
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
144
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
153
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
162
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
171
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
180
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
189
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
198
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
207
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
216
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
225
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
234
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
243
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
252
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
261
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
270
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
279
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
288
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
297
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
306
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
315
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
324
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
333
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
342
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
351
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
360
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
369
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
378
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
387
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
396
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
405
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
414
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
423
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
432
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
441
byte 00000FFFF
par 0
word 0
par 0
word 0
par 0
word 7F00
par 1
word 7FFF
word modificata con parità 100007FFF
450
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
459
byte FFF000000
par 8
word FF000000
par 12
word FFC00000
par 12
word FFC00000
par 12
word FFC00000
word modificata con parità CFFC00000
468
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
477
byte 00FFFFFFF
par 0
word 1000000
par 4
word 1FF0000
par 6
word 1FFFF00
par 7
word 1FFFFFF
word modificata con parità 701FFFFFF
486
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
495
byte 000000000
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 0
word modificata con parità 000000000
504
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
513
byte FFFFFFFFF
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFFF00
par 15
word FFFFFFFF
word modificata con parità FFFFFFFFF
522
byte FFFFFF000
par 8
word FF000000
par 12
word FFFF0000
par 14
word FFFFF800
par 14
word FFFFF800
word modificata con parità EFFFFF800
531
byte 00000F000
par 0
word 0
par 0
word 0
par 0
word 7800
par 0
word 7800
word modificata con parità 000007800
540
byte 00000F000
par 0
word 0
par 0
word 0
par 0
word 7800
par 0
word 7800
word modificata con parità 000007800
549
byte 00000F000
par 0
word 0
par 0
word 0
par 0
word 7800
par 0
word 7800
word modificata con parità 000007800
558
byte 00000F000
par 0
word 0
par 0
word 0
par 0
word 7800
par 0
word 7800
word modificata con parità 000007800
567
byte 000005
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 5
word modificata con parità 000000005
30000019F00000000F00000000FFFFFFFFFFEFFFFF800100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000000000100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000000000100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000000000100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000000000100007FFFFFFFFFFFFCFFC00000000000000701FFFFFFFFFFFFFFF00000000000000000FFFFFFFFFFEFFFFF800000007800000007800000007800000007800000000005
lunghezza 576
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr offset /32]
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
invalid bareword "offset"
in expression "offset /32";
should be "$offset" or "{offset}" or "offset(...)" or ...
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
invalid bareword "offset"
in expression "offset /32";
should be "$offset" or "{offset}" or "offset(...)" or ...
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
invalid bareword "offset"
in expression "offset /32";
should be "$offset" or "{offset}" or "offset(...)" or ...
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
invalid bareword "offset"
in expression "offset /32";
should be "$offset" or "{offset}" or "offset(...)" or ...
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr {offset / 32}]
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
invalid bareword "offset"
in expression "offset / 32";
should be "$offset" or "{offset}" or "offset(...)" or ...
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr offset / 32]
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
invalid bareword "offset"
in expression "offset / 32";
should be "$offset" or "{offset}" or "offset(...)" or ...
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
16
offset 540
contatore 0
16
offset 545
contatore 0
17
offset 570
contatore 0
17
offset 579
contatore 0
18
offset 604
contatore 0
18
offset 609
contatore 0
19
offset 634
contatore 0
19
offset 643
contatore 0
20
offset 668
contatore 0
20
offset 673
contatore 0
21
offset 698
contatore 0
21
offset 707
contatore 0
22
offset 732
contatore 0
22
offset 737
contatore 0
23
offset 762
contatore 0
23
offset 771
contatore 0
24
offset 796
contatore 0
24
offset 801
contatore 0
25
offset 826
contatore 0
25
offset 835
contatore 0
26
offset 860
contatore 0
26
offset 865
contatore 0
27
offset 890
contatore 0
27
offset 899
contatore 0
28
offset 924
contatore 0
28
offset 929
contatore 0
29
offset 954
contatore 0
29
offset 963
contatore 0
30
offset 988
contatore 0
30
offset 993
contatore 0
31
offset 1018
contatore 0
31
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 72
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			while {$f-1 >=15}
# 			{
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 				}
# 				
# 			}
# 
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
wrong # args: should be "while test command"
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			while {$f-1 >=15} {
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 				}
# 				
# 			}
# 
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
1
offset 540
contatore 0
1
offset 545
contatore 0
2
offset 570
contatore 0
2
offset 579
contatore 0
3
offset 604
contatore 0
3
offset 609
contatore 0
4
offset 634
contatore 0
4
offset 643
contatore 0
5
offset 668
contatore 0
5
offset 673
contatore 0
6
offset 698
contatore 0
6
offset 707
contatore 0
7
offset 732
contatore 0
7
offset 737
contatore 0
8
offset 762
contatore 0
8
offset 771
contatore 0
9
offset 796
contatore 0
9
offset 801
contatore 0
10
offset 826
contatore 0
10
offset 835
contatore 0
11
offset 860
contatore 0
11
offset 865
contatore 0
12
offset 890
contatore 0
12
offset 899
contatore 0
13
offset 924
contatore 0
13
offset 929
contatore 0
14
offset 954
contatore 0
14
offset 963
contatore 0
15
offset 988
contatore 0
15
offset 993
contatore 0
1
offset 1018
contatore 0
1
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
81
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
90
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
99
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
108
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
117
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
126
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
135
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
144
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
153
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
162
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
171
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
180
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
189
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
198
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
207
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
216
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
225
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
234
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
243
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
252
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
261
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
270
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
279
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
288
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
297
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
306
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
315
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
324
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
333
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
342
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
351
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
360
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
369
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 378
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			while {$f-1 >=15} {
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 				}
# 				
# 			}
# 			set i $f
# 
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
1
offset 540
contatore 1
1
offset 545
contatore 1
2
offset 570
contatore 2
2
offset 579
contatore 2
3
offset 604
contatore 3
3
offset 609
contatore 3
4
offset 634
contatore 4
4
offset 643
contatore 4
5
offset 668
contatore 5
5
offset 673
contatore 5
6
offset 698
contatore 6
6
offset 707
contatore 6
7
offset 732
contatore 7
7
offset 737
contatore 7
8
offset 762
contatore 8
8
offset 771
contatore 8
9
offset 796
contatore 9
9
offset 801
contatore 9
10
offset 826
contatore 10
10
offset 835
contatore 10
11
offset 860
contatore 11
11
offset 865
contatore 11
12
offset 890
contatore 12
12
offset 899
contatore 12
13
offset 924
contatore 13
13
offset 929
contatore 13
14
offset 954
contatore 14
14
offset 963
contatore 14
15
offset 988
contatore 15
15
offset 993
contatore 15
1
offset 1018
contatore 1
1
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
81
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
90
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
99
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
108
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
117
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
126
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
135
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
144
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
153
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
162
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
171
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
180
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
189
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
198
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
207
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
216
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
225
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
234
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
243
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
252
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
261
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
270
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
279
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
288
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
297
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
306
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
315
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
324
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
333
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
342
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
351
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
360
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
369
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 378
[{}]
c_r/
0
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
62
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			while {$f-1 >=15} {
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 				}
# 				
# 			}
# 			set i $f
# 
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
1
offset 540
contatore 1
1
offset 545
contatore 1
2
offset 570
contatore 2
2
offset 579
contatore 2
3
offset 604
contatore 3
3
offset 609
contatore 3
4
offset 634
contatore 4
4
offset 643
contatore 4
5
offset 668
contatore 5
5
offset 673
contatore 5
6
offset 698
contatore 6
6
offset 707
contatore 6
7
offset 732
contatore 7
7
offset 737
contatore 7
8
offset 762
contatore 8
8
offset 771
contatore 8
9
offset 796
contatore 9
9
offset 801
contatore 9
10
offset 826
contatore 10
10
offset 835
contatore 10
11
offset 860
contatore 11
11
offset 865
contatore 11
12
offset 890
contatore 12
12
offset 899
contatore 12
13
offset 924
contatore 13
13
offset 929
contatore 13
14
offset 954
contatore 14
14
offset 963
contatore 14
15
offset 988
contatore 15
15
offset 993
contatore 15
1
offset 1018
contatore 1
1
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
81
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
90
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
99
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
108
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
117
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
126
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
135
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
144
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
153
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
162
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
171
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
180
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
189
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
198
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
207
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
216
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
225
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
234
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
243
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
252
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
261
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
270
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
279
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
288
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
297
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
306
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
315
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
324
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
333
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
342
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
351
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
360
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
369
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 378
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			set f [expr $f-$i]
# 			puts $f
# 			while {$f-1 >=15} {
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 				}
# 				
# 			}
# 			set i $f
# 
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
16
1
offset 540
contatore 1
15
15
offset 545
contatore 15
2
2
offset 570
contatore 2
15
15
offset 579
contatore 15
3
3
offset 604
contatore 3
15
15
offset 609
contatore 15
4
4
offset 634
contatore 4
15
15
offset 643
contatore 15
5
5
offset 668
contatore 5
15
15
offset 673
contatore 15
6
6
offset 698
contatore 6
15
15
offset 707
contatore 15
7
7
offset 732
contatore 7
15
15
offset 737
contatore 15
8
8
offset 762
contatore 8
15
15
offset 771
contatore 15
9
9
offset 796
contatore 9
15
15
offset 801
contatore 15
10
10
offset 826
contatore 10
15
15
offset 835
contatore 15
11
11
offset 860
contatore 11
15
15
offset 865
contatore 15
12
12
offset 890
contatore 12
15
15
offset 899
contatore 15
13
13
offset 924
contatore 13
15
15
offset 929
contatore 15
14
14
offset 954
contatore 14
15
15
offset 963
contatore 15
15
15
offset 988
contatore 15
15
15
offset 993
contatore 15
16
1
offset 1018
contatore 1
30
15
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
81
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
90
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 99
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			while {$f-1 >=15} {
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 				}
# 				
# 			}
# 			set i $f
# 
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
numero frame 16
numero frame -i 16
1
offset 540
contatore 1
numero frame 16
numero frame -i 15
15
offset 545
contatore 15
numero frame 17
numero frame -i 2
2
offset 570
contatore 2
numero frame 17
numero frame -i 15
15
offset 579
contatore 15
numero frame 18
numero frame -i 3
3
offset 604
contatore 3
numero frame 18
numero frame -i 15
15
offset 609
contatore 15
numero frame 19
numero frame -i 4
4
offset 634
contatore 4
numero frame 19
numero frame -i 15
15
offset 643
contatore 15
numero frame 20
numero frame -i 5
5
offset 668
contatore 5
numero frame 20
numero frame -i 15
15
offset 673
contatore 15
numero frame 21
numero frame -i 6
6
offset 698
contatore 6
numero frame 21
numero frame -i 15
15
offset 707
contatore 15
numero frame 22
numero frame -i 7
7
offset 732
contatore 7
numero frame 22
numero frame -i 15
15
offset 737
contatore 15
numero frame 23
numero frame -i 8
8
offset 762
contatore 8
numero frame 23
numero frame -i 15
15
offset 771
contatore 15
numero frame 24
numero frame -i 9
9
offset 796
contatore 9
numero frame 24
numero frame -i 15
15
offset 801
contatore 15
numero frame 25
numero frame -i 10
10
offset 826
contatore 10
numero frame 25
numero frame -i 15
15
offset 835
contatore 15
numero frame 26
numero frame -i 11
11
offset 860
contatore 11
numero frame 26
numero frame -i 15
15
offset 865
contatore 15
numero frame 27
numero frame -i 12
12
offset 890
contatore 12
numero frame 27
numero frame -i 15
15
offset 899
contatore 15
numero frame 28
numero frame -i 13
13
offset 924
contatore 13
numero frame 28
numero frame -i 15
15
offset 929
contatore 15
numero frame 29
numero frame -i 14
14
offset 954
contatore 14
numero frame 29
numero frame -i 15
15
offset 963
contatore 15
numero frame 30
numero frame -i 15
15
offset 988
contatore 15
numero frame 30
numero frame -i 15
15
offset 993
contatore 15
numero frame 31
numero frame -i 16
1
offset 1018
contatore 1
numero frame 31
numero frame -i 30
15
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
81
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
90
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 99
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i $f
# 			while {$f-1 >=15} {
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 				}
# 				
# 			}
# 
# 			puts $f
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
numero frame 16
numero frame -i 16
1
offset 540
contatore 16
numero frame 16
numero frame -i 0
0
offset 545
contatore 0
numero frame 17
numero frame -i 17
2
offset 570
contatore 17
numero frame 17
numero frame -i 0
0
offset 579
contatore 0
numero frame 18
numero frame -i 18
3
offset 604
contatore 18
numero frame 18
numero frame -i 0
0
offset 609
contatore 0
numero frame 19
numero frame -i 19
4
offset 634
contatore 19
numero frame 19
numero frame -i 0
0
offset 643
contatore 0
numero frame 20
numero frame -i 20
5
offset 668
contatore 20
numero frame 20
numero frame -i 0
0
offset 673
contatore 0
numero frame 21
numero frame -i 21
6
offset 698
contatore 21
numero frame 21
numero frame -i 0
0
offset 707
contatore 0
numero frame 22
numero frame -i 22
7
offset 732
contatore 22
numero frame 22
numero frame -i 0
0
offset 737
contatore 0
numero frame 23
numero frame -i 23
8
offset 762
contatore 23
numero frame 23
numero frame -i 0
0
offset 771
contatore 0
numero frame 24
numero frame -i 24
9
offset 796
contatore 24
numero frame 24
numero frame -i 0
0
offset 801
contatore 0
numero frame 25
numero frame -i 25
10
offset 826
contatore 25
numero frame 25
numero frame -i 0
0
offset 835
contatore 0
numero frame 26
numero frame -i 26
11
offset 860
contatore 26
numero frame 26
numero frame -i 0
0
offset 865
contatore 0
numero frame 27
numero frame -i 27
12
offset 890
contatore 27
numero frame 27
numero frame -i 0
0
offset 899
contatore 0
numero frame 28
numero frame -i 28
13
offset 924
contatore 28
numero frame 28
numero frame -i 0
0
offset 929
contatore 0
numero frame 29
numero frame -i 29
14
offset 954
contatore 29
numero frame 29
numero frame -i 0
0
offset 963
contatore 0
numero frame 30
numero frame -i 30
15
offset 988
contatore 30
numero frame 30
numero frame -i 0
0
offset 993
contatore 0
numero frame 31
numero frame -i 31
1
offset 1018
contatore 31
numero frame 31
numero frame -i 0
0
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
81
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
90
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
99
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
108
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
117
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
126
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
135
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
144
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
153
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
162
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
171
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
180
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
189
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
198
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
207
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
216
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 225
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			while {$f-1 >=15} {
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				set i [expr $i+$f ]
# 			}
# 
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
numero frame 16
numero frame -i 16
offset 540
contatore 1
numero frame 16
numero frame -i 15
offset 545
contatore 1
numero frame 17
numero frame -i 16
offset 570
contatore 2
numero frame 17
numero frame -i 15
offset 579
contatore 2
numero frame 18
numero frame -i 16
offset 604
contatore 3
numero frame 18
numero frame -i 15
offset 609
contatore 3
numero frame 19
numero frame -i 16
offset 634
contatore 4
numero frame 19
numero frame -i 15
offset 643
contatore 4
numero frame 20
numero frame -i 16
offset 668
contatore 5
numero frame 20
numero frame -i 15
offset 673
contatore 5
numero frame 21
numero frame -i 16
offset 698
contatore 6
numero frame 21
numero frame -i 15
offset 707
contatore 6
numero frame 22
numero frame -i 16
offset 732
contatore 7
numero frame 22
numero frame -i 15
offset 737
contatore 7
numero frame 23
numero frame -i 16
offset 762
contatore 8
numero frame 23
numero frame -i 15
offset 771
contatore 8
numero frame 24
numero frame -i 16
offset 796
contatore 9
numero frame 24
numero frame -i 15
offset 801
contatore 9
numero frame 25
numero frame -i 16
offset 826
contatore 10
numero frame 25
numero frame -i 15
offset 835
contatore 10
numero frame 26
numero frame -i 16
offset 860
contatore 11
numero frame 26
numero frame -i 15
offset 865
contatore 11
numero frame 27
numero frame -i 16
offset 890
contatore 12
numero frame 27
numero frame -i 15
offset 899
contatore 12
numero frame 28
numero frame -i 16
offset 924
contatore 13
numero frame 28
numero frame -i 15
offset 929
contatore 13
numero frame 29
numero frame -i 16
offset 954
contatore 14
numero frame 29
numero frame -i 15
offset 963
contatore 14
numero frame 30
numero frame -i 16
offset 988
contatore 15
numero frame 30
numero frame -i 15
offset 993
contatore 15
numero frame 31
numero frame -i 16
offset 1018
contatore 16
numero frame 31
numero frame -i 15
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
81
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
90
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
99
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
108
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
117
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
126
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
135
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
144
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
153
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
162
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
171
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
180
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
189
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
198
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
207
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 216
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i [expr $i+$f ]
# 			while {$f-1 >=15} {
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				
# 			}
# 
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
numero frame 16
numero frame -i 16
offset 540
contatore 16
numero frame 16
numero frame -i 0
offset 545
contatore 16
numero frame 17
numero frame -i 1
offset 570
contatore 17
numero frame 17
numero frame -i 0
offset 579
contatore 17
numero frame 18
numero frame -i 1
offset 604
contatore 18
numero frame 18
numero frame -i 0
offset 609
contatore 18
numero frame 19
numero frame -i 1
offset 634
contatore 19
numero frame 19
numero frame -i 0
offset 643
contatore 19
numero frame 20
numero frame -i 1
offset 668
contatore 20
numero frame 20
numero frame -i 0
offset 673
contatore 20
numero frame 21
numero frame -i 1
offset 698
contatore 21
numero frame 21
numero frame -i 0
offset 707
contatore 21
numero frame 22
numero frame -i 1
offset 732
contatore 22
numero frame 22
numero frame -i 0
offset 737
contatore 22
numero frame 23
numero frame -i 1
offset 762
contatore 23
numero frame 23
numero frame -i 0
offset 771
contatore 23
numero frame 24
numero frame -i 1
offset 796
contatore 24
numero frame 24
numero frame -i 0
offset 801
contatore 24
numero frame 25
numero frame -i 1
offset 826
contatore 25
numero frame 25
numero frame -i 0
offset 835
contatore 25
numero frame 26
numero frame -i 1
offset 860
contatore 26
numero frame 26
numero frame -i 0
offset 865
contatore 26
numero frame 27
numero frame -i 1
offset 890
contatore 27
numero frame 27
numero frame -i 0
offset 899
contatore 27
numero frame 28
numero frame -i 1
offset 924
contatore 28
numero frame 28
numero frame -i 0
offset 929
contatore 28
numero frame 29
numero frame -i 1
offset 954
contatore 29
numero frame 29
numero frame -i 0
offset 963
contatore 29
numero frame 30
numero frame -i 1
offset 988
contatore 30
numero frame 30
numero frame -i 0
offset 993
contatore 30
numero frame 31
numero frame -i 1
offset 1018
contatore 31
numero frame 31
numero frame -i 0
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 81
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i [expr $i+$f ]
# 			while {$f-1 >0} {
# 				set stessa_word 0
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				
# 			}
# 
# 			if {$stessa_word ==0} {
# 					#append bram " salto"
# 					#append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					#puts "frame_da_saltare $frame_da_saltare"
# 					#set frame_da_saltare -1
# 					#append bram "word"
# 					set word [expr 1 << [expr $offset % 32]]
# 					#puts "word $word"
# 					#append bram [format %X [expr $offset % 32]]
# 					#puts [format %x [expr $offset % 32]]
# 					#append bram " "
# 					set stessa_word 1
# 				} else {
# 					
# 					set sec_word [expr 1 << [expr $offset % 32]]
# 					#puts $sec_word
# 					#puts "seconda word $sec_word" 
# 					set word [expr $word | $sec_word] 
# 					#questa or mi permette di mettere più offset nella stessa maschera
# 					#puts $word
# 					#append bram [format %X [expr $offset % 32]]
# 					#append bram " "
# 				}
# 			puts "numero word $f"
# 			puts "bram $bram"
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
numero frame 16
numero frame -i 16
numero word 1
bram 00002039f00000000F
offset 540
contatore 16
numero frame 16
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 545
contatore 16
numero frame 17
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 570
contatore 17
numero frame 17
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 579
contatore 17
numero frame 18
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 604
contatore 18
numero frame 18
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 609
contatore 18
numero frame 19
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 634
contatore 19
numero frame 19
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 643
contatore 19
numero frame 20
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 668
contatore 20
numero frame 20
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 673
contatore 20
numero frame 21
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 698
contatore 21
numero frame 21
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 707
contatore 21
numero frame 22
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 732
contatore 22
numero frame 22
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 737
contatore 22
numero frame 23
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 762
contatore 23
numero frame 23
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 771
contatore 23
numero frame 24
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 796
contatore 24
numero frame 24
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 801
contatore 24
numero frame 25
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 826
contatore 25
numero frame 25
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 835
contatore 25
numero frame 26
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 860
contatore 26
numero frame 26
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 865
contatore 26
numero frame 27
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 890
contatore 27
numero frame 27
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 899
contatore 27
numero frame 28
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 924
contatore 28
numero frame 28
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 929
contatore 28
numero frame 29
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 954
contatore 29
numero frame 29
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 963
contatore 29
numero frame 30
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 988
contatore 30
numero frame 30
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 993
contatore 30
numero frame 31
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 1018
contatore 31
numero frame 31
numero frame -i 0
numero word 0
bram 00002039f00000000F
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 81
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i [expr $i+$f ]
# 			while {$f-1 >0} {
# 				set stessa_word 0
# 				puts "qui"
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				
# 			}
# 
# 			if {$stessa_word ==0} {
# 					#append bram " salto"
# 					#append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					#puts "frame_da_saltare $frame_da_saltare"
# 					#set frame_da_saltare -1
# 					#append bram "word"
# 					set word [expr 1 << [expr $offset % 32]]
# 					#puts "word $word"
# 					#append bram [format %X [expr $offset % 32]]
# 					#puts [format %x [expr $offset % 32]]
# 					#append bram " "
# 					set stessa_word 1
# 				} else {
# 					
# 					set sec_word [expr 1 << [expr $offset % 32]]
# 					#puts $sec_word
# 					#puts "seconda word $sec_word" 
# 					set word [expr $word | $sec_word] 
# 					#questa or mi permette di mettere più offset nella stessa maschera
# 					#puts $word
# 					#append bram [format %X [expr $offset % 32]]
# 					#append bram " "
# 				}
# 			puts "numero word $f"
# 			puts "bram $bram"
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
numero frame 16
numero frame -i 16
qui
numero word 1
bram 00002039f00000000F
offset 540
contatore 16
numero frame 16
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 545
contatore 16
numero frame 17
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 570
contatore 17
numero frame 17
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 579
contatore 17
numero frame 18
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 604
contatore 18
numero frame 18
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 609
contatore 18
numero frame 19
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 634
contatore 19
numero frame 19
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 643
contatore 19
numero frame 20
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 668
contatore 20
numero frame 20
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 673
contatore 20
numero frame 21
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 698
contatore 21
numero frame 21
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 707
contatore 21
numero frame 22
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 732
contatore 22
numero frame 22
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 737
contatore 22
numero frame 23
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 762
contatore 23
numero frame 23
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 771
contatore 23
numero frame 24
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 796
contatore 24
numero frame 24
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 801
contatore 24
numero frame 25
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 826
contatore 25
numero frame 25
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 835
contatore 25
numero frame 26
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 860
contatore 26
numero frame 26
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 865
contatore 26
numero frame 27
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 890
contatore 27
numero frame 27
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 899
contatore 27
numero frame 28
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 924
contatore 28
numero frame 28
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 929
contatore 28
numero frame 29
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 954
contatore 29
numero frame 29
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 963
contatore 29
numero frame 30
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 988
contatore 30
numero frame 30
numero frame -i 0
numero word 0
bram 00002039f00000000F
offset 993
contatore 30
numero frame 31
numero frame -i 1
numero word 1
bram 00002039f00000000F
offset 1018
contatore 31
numero frame 31
numero frame -i 0
numero word 0
bram 00002039f00000000F
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
27
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
36
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
45
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
54
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
63
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
72
byte 000000004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F00000000F00000000F00000000F00000000F00000000F00000000F000000004
lunghezza 81
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i [expr $i+$f ]
# 			while {$f-1 >0} {
# 				set stessa_word 0
# 				append bram [format %X [expr $word]]
# 				puts "qui"
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				
# 			}
# 
# 			if {$stessa_word ==0} {
# 					#append bram " salto"
# 					#append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					#puts "frame_da_saltare $frame_da_saltare"
# 					#set frame_da_saltare -1
# 					#append bram "word"
# 					set word [expr 1 << [expr $offset % 32]]
# 					#puts "word $word"
# 					#append bram [format %X [expr $offset % 32]]
# 					#puts [format %x [expr $offset % 32]]
# 					#append bram " "
# 					set stessa_word 1
# 				} else {
# 					
# 					set sec_word [expr 1 << [expr $offset % 32]]
# 					#puts $sec_word
# 					#puts "seconda word $sec_word" 
# 					set word [expr $word | $sec_word] 
# 					#questa or mi permette di mettere più offset nella stessa maschera
# 					#puts $word
# 					#append bram [format %X [expr $offset % 32]]
# 					#append bram " "
# 				}
# 			puts "numero word $f"
# 			puts "bram $bram"
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
numero frame 16
numero frame -i 16
can't read "word": no such variable
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i [expr $i+$f ]
# 			while {$f-1 >0} {
# 				set stessa_word 0
# 				puts "qui"
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				
# 			}
# 
# 			if {$stessa_word ==0} {
# 					#append bram " salto"
# 					#append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					#puts "frame_da_saltare $frame_da_saltare"
# 					#set frame_da_saltare -1
# 					#append bram "word"
# 					set word [expr 1 << [expr $offset % 32]]
# 					#puts "word $word"
# 					#append bram [format %X [expr $offset % 32]]
# 					#puts [format %x [expr $offset % 32]]
# 					#append bram " "
# 					set stessa_word 1
# 				} else {
# 					
# 					set sec_word [expr 1 << [expr $offset % 32]]
# 					#puts $sec_word
# 					#puts "seconda word $sec_word" 
# 					set word [expr $word | $sec_word] 
# 					#questa or mi permette di mettere più offset nella stessa maschera
# 					#puts $word
# 					#append bram [format %X [expr $offset % 32]]
# 					#append bram " "
# 				}
# 				if {$f>=1} {
# 						append bram [format %X [expr $word]]
# 				}
# 
# 			puts "numero word $f"
# 			puts "bram $bram"
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
dict 515 540 545 570 579 604 609 634 643 668 673 698 707 732 737 762 771 796 801 826 835 860 865 890 899 924 929 954 963 988 993 1018 
offset 515
contatore 0
numero frame 16
numero frame -i 16
qui
numero word 1
bram 00002039f00000000F8
offset 540
contatore 16
numero frame 16
numero frame -i 0
numero word 0
bram 00002039f00000000F8
offset 545
contatore 16
numero frame 17
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A
offset 570
contatore 17
numero frame 17
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A
offset 579
contatore 17
numero frame 18
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A
offset 604
contatore 18
numero frame 18
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A
offset 609
contatore 18
numero frame 19
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A
offset 634
contatore 19
numero frame 19
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A
offset 643
contatore 19
numero frame 20
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A
offset 668
contatore 20
numero frame 20
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A
offset 673
contatore 20
numero frame 21
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A
offset 698
contatore 21
numero frame 21
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A
offset 707
contatore 21
numero frame 22
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A
offset 732
contatore 22
numero frame 22
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A
offset 737
contatore 22
numero frame 23
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 762
contatore 23
numero frame 23
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 771
contatore 23
numero frame 24
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 796
contatore 24
numero frame 24
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 801
contatore 24
numero frame 25
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 826
contatore 25
numero frame 25
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 835
contatore 25
numero frame 26
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 860
contatore 26
numero frame 26
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 865
contatore 26
numero frame 27
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 890
contatore 27
numero frame 27
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 899
contatore 27
numero frame 28
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 924
contatore 28
numero frame 28
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 929
contatore 28
numero frame 29
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 954
contatore 29
numero frame 29
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 963
contatore 29
numero frame 30
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 988
contatore 30
numero frame 30
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 993
contatore 30
numero frame 31
numero frame -i 1
numero word 1
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
offset 1018
contatore 31
numero frame 31
numero frame -i 0
numero word 0
bram 00002039f00000000F81000000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A1400000A
0
byte 00002039f
par 0
word 0
par 0
word 0
par 2
word 100
par 3
word 19F
word modificata con parità 30000019F
9
byte 00000000F
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word F
word modificata con parità 00000000F
18
byte 81000000A
par 8
word 2000000
par 8
word 2000000
par 8
word 2000000
par 8
word 200000A
word modificata con parità 80200000A
27
byte 1400000A1
par 0
word 28000000
par 0
word 28000000
par 0
word 28000000
par 0
word 280000A1
word modificata con parità 0280000A1
36
byte 400000A14
par 0
word 80000000
par 0
word 80000000
par 0
word 80000500
par 0
word 80000514
word modificata con parità 080000514
45
byte 00000A140
par 0
word 0
par 0
word 0
par 0
word 5000
par 1
word 5040
word modificata con parità 100005040
54
byte 0000A1400
par 0
word 0
par 0
word 20000
par 2
word 20A00
par 2
word 20A00
word modificata con parità 200020A00
63
byte 000A14000
par 0
word 0
par 0
word 280000
par 0
word 28A000
par 0
word 28A000
word modificata con parità 00028A000
72
byte 00A140000
par 0
word 1000000
par 0
word 1850000
par 0
word 1850000
par 0
word 1850000
word modificata con parità 001850000
81
byte 0A1400000
par 0
word 14000000
par 0
word 14500000
par 0
word 14500000
par 0
word 14500000
word modificata con parità 014500000
90
byte A1400000A
par 8
word 42000000
par 12
word 42000000
par 12
word 42000000
par 12
word 4200000A
word modificata con parità C4200000A
99
byte 1400000A1
par 0
word 28000000
par 0
word 28000000
par 0
word 28000000
par 0
word 280000A1
word modificata con parità 0280000A1
108
byte 400000A14
par 0
word 80000000
par 0
word 80000000
par 0
word 80000500
par 0
word 80000514
word modificata con parità 080000514
117
byte 00000A140
par 0
word 0
par 0
word 0
par 0
word 5000
par 1
word 5040
word modificata con parità 100005040
126
byte 0000A1400
par 0
word 0
par 0
word 20000
par 2
word 20A00
par 2
word 20A00
word modificata con parità 200020A00
135
byte 000A00000
par 0
word 0
par 0
word 280000
par 0
word 280000
par 0
word 280000
word modificata con parità 000280000
144
byte 000F00000
par 0
word 0
par 0
word 3C0000
par 0
word 3C0000
par 0
word 3C0000
word modificata con parità 0003C0000
153
byte 000F00000
par 0
word 0
par 0
word 3C0000
par 0
word 3C0000
par 0
word 3C0000
word modificata con parità 0003C0000
162
byte 000F00000
par 0
word 0
par 0
word 3C0000
par 0
word 3C0000
par 0
word 3C0000
word modificata con parità 0003C0000
171
byte 000F00000
par 0
word 0
par 0
word 3C0000
par 0
word 3C0000
par 0
word 3C0000
word modificata con parità 0003C0000
180
byte 000F00000
par 0
word 0
par 0
word 3C0000
par 0
word 3C0000
par 0
word 3C0000
word modificata con parità 0003C0000
189
byte 000F00000
par 0
word 0
par 0
word 3C0000
par 0
word 3C0000
par 0
word 3C0000
word modificata con parità 0003C0000
198
byte 0004
par 0
word 0
par 0
word 0
par 0
word 0
par 0
word 4
word modificata con parità 000000004
30000019F00000000F80200000A0280000A1080000514100005040200020A0000028A000001850000014500000C4200000A0280000A1080000514100005040200020A000002800000003C00000003C00000003C00000003C00000003C00000003C0000000000004
lunghezza 207
[{}]
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		array set offset {}
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		set offset [dict get $mydict $frame]
# 		#puts offset [array names ]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i [expr $i+$f ]
# 			while {$f-1 >0} {
# 				set stessa_word 0
# 				puts "qui"
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				
# 			}
# 
# 			if {$stessa_word ==0} {
# 					#append bram " salto"
# 					#append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					#puts "frame_da_saltare $frame_da_saltare"
# 					#set frame_da_saltare -1
# 					#append bram "word"
# 					set word [expr 1 << [expr $offset % 32]]
# 					#puts "word $word"
# 					#append bram [format %X [expr $offset % 32]]
# 					#puts [format %x [expr $offset % 32]]
# 					#append bram " "
# 					set stessa_word 1
# 				} else {
# 					
# 					set sec_word [expr 1 << [expr $offset % 32]]
# 					#puts $sec_word
# 					#puts "seconda word $sec_word" 
# 					set word [expr $word | $sec_word] 
# 					#questa or mi permette di mettere più offset nella stessa maschera
# 					#puts $word
# 					#append bram [format %X [expr $offset % 32]]
# 					#append bram " "
# 				}
# 				if {$f>=1} {
# 						append bram [format %X [expr $word]]
# 				}
# 
# 			puts "numero word $f"
# 			puts "bram $bram"
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
can't array set "offset": variable isn't array
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		array set offset {}
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		array set offset [dict get $mydict $frame]
# 		#puts offset [array names ]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i [expr $i+$f ]
# 			while {$f-1 >0} {
# 				set stessa_word 0
# 				puts "qui"
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				
# 			}
# 
# 			if {$stessa_word ==0} {
# 					#append bram " salto"
# 					#append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					#puts "frame_da_saltare $frame_da_saltare"
# 					#set frame_da_saltare -1
# 					#append bram "word"
# 					set word [expr 1 << [expr $offset % 32]]
# 					#puts "word $word"
# 					#append bram [format %X [expr $offset % 32]]
# 					#puts [format %x [expr $offset % 32]]
# 					#append bram " "
# 					set stessa_word 1
# 				} else {
# 					
# 					set sec_word [expr 1 << [expr $offset % 32]]
# 					#puts $sec_word
# 					#puts "seconda word $sec_word" 
# 					set word [expr $word | $sec_word] 
# 					#questa or mi permette di mettere più offset nella stessa maschera
# 					#puts $word
# 					#append bram [format %X [expr $offset % 32]]
# 					#append bram " "
# 				}
# 				if {$f>=1} {
# 						append bram [format %X [expr $word]]
# 				}
# 
# 			puts "numero word $f"
# 			puts "bram $bram"
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
can't array set "offset": variable isn't array
source /home/saverio/Scrivania/tesi/script/trovare_indirizzi_in_ll.tcl
# proc swap_half_word {data} { 
# 	set new_data ""
# 	for {set x 0} {$x<[string length $data]} {incr x 2} {
# 		append new_data [string range $data  $x+1 $x+1]
# 		append new_data [string range $data  $x $x]
# 	}
# 	return $new_data
# }
# proc searchinfile {filename component} {
# 	set mydict [dict create] 
# 	#uso dizionario perchè ad ogni frame (chiave) do più valori
# 	puts $component
# 	set file [open $filename]
# 	while {[gets $file line] != -1} {
# 	    if {[regexp "$component" $line all value]} {
# 	        
# 	        set line [string map {" " ""} $line]
# 	        #puts $line
# 	        set pos [string first 0x $line] 
# 	        set frame "0"
# 	        append frame [string range $line $pos+2 $pos+9] 
# 	        puts "frame $frame"
# 	        # prendo il frame
# 	        set offset ""
# 	        set i 10
# 	        set check_number [string range $line $pos+$i $pos+$i]
# 	        #questo while mi serve per prendere i valori di offset dopo il frame, perchè dopo offset ho carattere
# 	        #l'offset presente nel .ll
# 	        while {[string is integer $check_number]} { 
# 	        	set i [expr {$i + 1}]
# 	        	#puts $check_number
# 	        	append offset $check_number
# 	        	set check_number [string range $line $pos+$i $pos+$i]
# 	        }
# 	        append offset " "
# 	        #puts $offset
# 	        dict append mydict $frame $offset 
# 	    }
# 	} 
# 	#puts [dict get $mydict $frame]
# 	set bram ""
# 	#per ogni frame calcolo salto degli offset
# 	foreach frame [dict keys $mydict]  { 
# 		append bram $frame
# 		#append bram "\n"
# 		#append bram " "
# 		#append bram 00000000
# 		#append bram " "
# 		set i 0
# 		set f 0
# 		set frame_da_saltare -1
# 		puts "prima bram $bram"
# 		set stessa_word 0
# 		array set offset {}
# 		puts "dict [dict get $mydict $frame]"
# 		# per ogni offset vedo quanti salti ci sono
# 		#array set offset [dict get $mydict $frame]
# 		#puts offset [array names ]
# 		foreach offset [dict get $mydict $frame] { 
# 
# 			puts "offset $offset"
# 			puts "contatore $i"
# 			set f [expr $offset / 32]
# 			puts "numero frame $f"
# 			set f [expr $f-$i]
# 			puts "numero frame -i $f"
# 			set i [expr $i+$f ]
# 			while {$f-1 >0} {
# 				set stessa_word 0
# 				puts "qui"
# 				if {$f-1 >=15} {
# 					append bram 00000000F 
# 					set f [expr $f -15]
# 					
# 				} else {
# 					append bram 00000000
# 					append bram [format %X $f] 
# 					
# 				}
# 				
# 			}
# 
# 			if {$stessa_word ==0} {
# 					#append bram " salto"
# 					#append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					#puts "frame_da_saltare $frame_da_saltare"
# 					#set frame_da_saltare -1
# 					#append bram "word"
# 					set word [expr 1 << [expr $offset % 32]]
# 					#puts "word $word"
# 					#append bram [format %X [expr $offset % 32]]
# 					#puts [format %x [expr $offset % 32]]
# 					#append bram " "
# 					set stessa_word 1
# 				} else {
# 					
# 					set sec_word [expr 1 << [expr $offset % 32]]
# 					#puts $sec_word
# 					#puts "seconda word $sec_word" 
# 					set word [expr $word | $sec_word] 
# 					#questa or mi permette di mettere più offset nella stessa maschera
# 					#puts $word
# 					#append bram [format %X [expr $offset % 32]]
# 					#append bram " "
# 				}
# 				if {$f>=1} {
# 						append bram [format %X [expr $word]]
# 				}
# 
# 			puts "numero word $f"
# 			puts "bram $bram"
# 			
# 			
# 			# while {$i<$offset} {
# 			# 		if {$stessa_word ==1} {
# 			# 			set stessa_word 0
# 			# 			#append bram "word"
# 			# 			append bram [format %08X $word]
# 			# 			#puts "word [format %X $word] "
# 			# 		}
# 			# 		#al massimo saltiamo 15 frame
# 			# 		if {$frame_da_saltare<15} {
# 			# 			set i [expr {$i + 32}]
# 			# 			set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 			# 			puts "qui $frame_da_saltare"
# 
# 
# 			# 		} else {
# 			# 			#append bram " salto"
# 			# 			set i [expr {$i + 32}]
# 			# 			append bram 00000000 
# 			# 			#append bram [format %X $frame_da_saltare] 
# 			# 			#append bram " "
# 						
# 			# 			#append bram " "
# 						
# 			# 			#set frame_da_saltare -1
# 						
# 			# 		}
# 			# 	}
# 
# 			# 	#questo if mi serve per capire se all' interno di una maschera devo mettere più uno
# 			# 	#poichè può darsi che due offset siano nella stessa word
# 				
# 
# 			# 	if {$stessa_word ==0} {
# 			# 		#append bram " salto"
# 			# 		append bram [format %X $frame_da_saltare] 
# 			# 		#append bram " "
# 			# 		puts "frame_da_saltare $frame_da_saltare"
# 			# 		set frame_da_saltare -1
# 			# 		#append bram "word"
# 			# 		set word [expr 1 << [expr $offset % 32]]
# 			# 		#puts "word $word"
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#puts [format %x [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 		set f [expr {$f +1 }]
# 			# 		set stessa_word 1
# 			# 	} else {
# 					
# 			# 		set sec_word [expr 1 << [expr $offset % 32]]
# 			# 		#puts $sec_word
# 			# 		#puts "seconda word $sec_word" 
# 			# 		set f [expr {$f + 1}]
# 			# 		set word [expr $word | $sec_word] 
# 			# 		#questa or mi permette di mettere più offset nella stessa maschera
# 			# 		#puts $word
# 			# 		#append bram [format %X [expr $offset % 32]]
# 			# 		#append bram " "
# 			# 	}
# 			# puts "numero word $f"
# 			# puts "bram $bram"
# 			
# 		}
# 		#puts $i
# 		#puts "f_s $frame_da_saltare"
# 		#riempio di salti e zero fino a che non riempio il frame
# 		while {$i<3232} {
# 				
# 				if {$frame_da_saltare<15} {
# 					set i [expr {$i + 32}]
# 					set frame_da_saltare [expr {$frame_da_saltare + 1}]
# 					#puts "qui $frame_da_saltare"
# 
# 				} else {
# 					#append bram "word "
# 					append bram 00000000 
# 					#append bram " "
# 					#append bram " salto"
# 					append bram [format %X $frame_da_saltare] 
# 					#append bram " "
# 					
# 					
# 					set frame_da_saltare -1
# 					#puts $i
# 					#puts $frame_da_saltare
# 				}
# 			}
# 			#se non ho scritto l' ultimo salto
# 			if {$frame_da_saltare!=0} {
# 				#append bram "word "
# 				append bram 00000000 
# 				#append bram " "
# 				#append bram " salto"
# 				append bram [format %X $frame_da_saltare] 
# 				#append bram $frame_da_saltare
# 				#append bram " "
# 				set frame_da_saltare -1
# 			}
# 			#puts $i
# 			set i 0
# 			append bram "               "
# 	}
# 	#puts $bram
# 	#set bram [swap_half_word $bram]
# 	#puts $bram
# 	close $file
# 
# 	set bram [string map {" " ""} $bram]
# 	set bram [get_parity $bram]
# 	puts $bram
# 	puts "lunghezza [string length $bram]"
# 	set f "/home/saverio/Scrivania/tesi/script/bram/test.mem"
# 	set fileId [open $f w]
# 	puts $fileId "@00000000"
# 	#scrivo i dati a word di 32 bit altrimenti il file .mem non li riconosce
# 	for {set x 0} {$x<[string length $bram]-8} {incr x 9} {
# 		
# 		puts $fileId [string range $bram $x $x+8]
# 	}
# 	set l_s [string range $bram $x end]
# 	#aggiungo zeri per far si di avere una word da 32
# 	#for {set x [string length $l_s]} {$x<9} {incr x } {
# 	#	append l_s 0
# 	#}
# 	puts $fileId $l_s
# 	close $fileId
# 	
# }
# proc search_for_frame {filename} {
#  [searchinfile $filename "c_r/"]
#  #[get_parity "FFFFFFFFA"]
# }
# proc get_parity {byte_string} {
# 	set par "0"
# 	set word "0"
# 	set parmask 800000000
# 	set bytemask 7F8000000
# 	set data ""
# 	for {set i 0} {$i<[expr [string length $byte_string]]} {incr i 9} {
# 		puts $i
# 		set byte [string range $byte_string $i $i+8]
# 		puts "byte $byte"
# 		for {set x 0} {$x<4} {incr x} {
# 		set par [expr $par |  [string range [format %X [expr [expr 0x$byte & [expr 0x$parmask>>$x*9]] <<9*$x+1+(3-$x)  ] ] 0 0]]
# 		puts "par $par"
# 		#puts [format %X [expr 0x$parmask>>$x*9]]
# 		#puts [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]]
# 		#puts [string range [format %X [expr [expr 0x$byte_string & [expr 0x$parmask>>$x*9]] << 9*$x+1+$x]] 0 0] 
# 		
# 			set word [expr $word | [expr 0x$byte & [expr 0x$bytemask >>$x*9]]>>3-$x ]
# 		
# 		
# 		puts "word [format %X  $word ]"
# 		}
# 		#set par [format %b $par]
# 		set par [format %X $par]
# 		set word [format %X  $word ] 
# 		while {[string length $word]<8} {
# 			set word "0$word"
# 		}
# 		
# 		append par $word
# 		puts "word modificata con parità $par"
# 		append data $par
# 		set par "0"
# 		set word "0"
# 	}
# 	return $data
# 	
# }
search_for_frame /home/saverio/Scrivania/codice_tesi/gestore_checkpoint/gestore_checkpoint.runs/impl_1/gestore_checkpoint.ll
c_r/
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
frame 00002039f
prima bram 00002039f
can't array set "offset": variable isn't array
